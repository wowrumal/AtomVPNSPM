#if 0
#elif defined(__arm64__) && __arm64__
// Generated by Apple Swift version 6.1.2 effective-5.10 (swiftlang-6.1.2.1.2 clang-1700.0.13.5)
#ifndef ATOMCORE_SWIFT_H
#define ATOMCORE_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#if defined(__OBJC__)
#include <Foundation/Foundation.h>
#endif
#if defined(__cplusplus)
#include <cstdint>
#include <cstddef>
#include <cstdbool>
#include <cstring>
#include <stdlib.h>
#include <new>
#include <type_traits>
#else
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#endif
#if defined(__cplusplus)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wnon-modular-include-in-framework-module"
#if defined(__arm64e__) && __has_include(<ptrauth.h>)
# include <ptrauth.h>
#else
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wreserved-macro-identifier"
# ifndef __ptrauth_swift_value_witness_function_pointer
#  define __ptrauth_swift_value_witness_function_pointer(x)
# endif
# ifndef __ptrauth_swift_class_method_pointer
#  define __ptrauth_swift_class_method_pointer(x)
# endif
#pragma clang diagnostic pop
#endif
#pragma clang diagnostic pop
#endif

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef unsigned char char8_t;
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...) 
# endif
#endif
#if !defined(SWIFT_RUNTIME_NAME)
# if __has_attribute(objc_runtime_name)
#  define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
# else
#  define SWIFT_RUNTIME_NAME(X) 
# endif
#endif
#if !defined(SWIFT_COMPILE_NAME)
# if __has_attribute(swift_name)
#  define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
# else
#  define SWIFT_COMPILE_NAME(X) 
# endif
#endif
#if !defined(SWIFT_METHOD_FAMILY)
# if __has_attribute(objc_method_family)
#  define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
# else
#  define SWIFT_METHOD_FAMILY(X) 
# endif
#endif
#if !defined(SWIFT_NOESCAPE)
# if __has_attribute(noescape)
#  define SWIFT_NOESCAPE __attribute__((noescape))
# else
#  define SWIFT_NOESCAPE 
# endif
#endif
#if !defined(SWIFT_RELEASES_ARGUMENT)
# if __has_attribute(ns_consumed)
#  define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
# else
#  define SWIFT_RELEASES_ARGUMENT 
# endif
#endif
#if !defined(SWIFT_WARN_UNUSED_RESULT)
# if __has_attribute(warn_unused_result)
#  define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
# else
#  define SWIFT_WARN_UNUSED_RESULT 
# endif
#endif
#if !defined(SWIFT_NORETURN)
# if __has_attribute(noreturn)
#  define SWIFT_NORETURN __attribute__((noreturn))
# else
#  define SWIFT_NORETURN 
# endif
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA 
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA 
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA 
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif
#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif
#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER 
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility) 
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED_OBJC)
# if __has_feature(attribute_diagnose_if_objc)
#  define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
# else
#  define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
# endif
#endif
#if defined(__OBJC__)
#if !defined(IBSegueAction)
# define IBSegueAction 
#endif
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if !defined(SWIFT_CALL)
# define SWIFT_CALL __attribute__((swiftcall))
#endif
#if !defined(SWIFT_INDIRECT_RESULT)
# define SWIFT_INDIRECT_RESULT __attribute__((swift_indirect_result))
#endif
#if !defined(SWIFT_CONTEXT)
# define SWIFT_CONTEXT __attribute__((swift_context))
#endif
#if !defined(SWIFT_ERROR_RESULT)
# define SWIFT_ERROR_RESULT __attribute__((swift_error_result))
#endif
#if defined(__cplusplus)
# define SWIFT_NOEXCEPT noexcept
#else
# define SWIFT_NOEXCEPT 
#endif
#if !defined(SWIFT_C_INLINE_THUNK)
# if __has_attribute(always_inline)
# if __has_attribute(nodebug)
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline)) __attribute__((nodebug))
# else
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline))
# endif
# else
#  define SWIFT_C_INLINE_THUNK inline
# endif
#endif
#if defined(_WIN32)
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL __declspec(dllimport)
#endif
#else
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL 
#endif
#endif
#if defined(__OBJC__)
#if __has_feature(objc_modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import Foundation;
@import ObjectiveC;
#endif

#endif
#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"
#pragma clang diagnostic ignored "-Wunsafe-buffer-usage"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="AtomCore",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

#if defined(__OBJC__)

@class NSString;
SWIFT_CLASS("_TtC8AtomCore16AccessTokenModel")
@interface AccessTokenModel : NSObject
@property (nonatomic, copy) NSString * _Nullable accessToken;
@property (nonatomic, copy) NSString * _Nullable refreshToken;
@property (nonatomic, copy) NSString * _Nullable resellerId;
@property (nonatomic, copy) NSString * _Nullable resellerUid;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

SWIFT_CLASS("_TtC8AtomCore15ApiBaseUrlModel")
@interface ApiBaseUrlModel : NSObject
@property (nonatomic, copy) NSString * _Nullable base_url;
@property (nonatomic, copy) NSString * _Nullable secondary_base_url;
@property (nonatomic, copy) NSString * _Nullable auth_accessToken;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

SWIFT_CLASS("_TtC8AtomCore18AppHelperFunctions")
@interface AppHelperFunctions : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class NSBundle;
@interface AppHelperFunctions (SWIFT_EXTENSION(AtomCore))
/// This method will return the user agent to be used in all network request
/// \param bundle bundle for the class name for framework
///
///
/// returns:
/// String to be used in User-Agent
- (NSString * _Nullable)getUserAgentForNetworkRequestWithBundle:(NSBundle * _Nonnull)bundle SWIFT_WARN_UNUSED_RESULT;
/// This method will return the display name of the passed bundle
/// \param bundle bundle for class name or main
///
///
/// returns:
/// disply name of the passed bundle
- (NSString * _Nullable)displayName:(NSBundle * _Nonnull)bundle SWIFT_WARN_UNUSED_RESULT;
/// This method will return the version number of the passed bundle
/// \param bundle bundle for class name or main
///
///
/// returns:
/// version number of the passed bundle
- (NSString * _Nullable)versionNumber:(NSBundle * _Nullable)bundle SWIFT_WARN_UNUSED_RESULT;
/// This method will return the build number of the passed bundle
/// \param bundle bundle for class name or main
///
///
/// returns:
/// build number of the passed bundle
- (NSString * _Nullable)buildNumber:(NSBundle * _Nullable)bundle SWIFT_WARN_UNUSED_RESULT;
@end

/// Protocol for analytics providers that can be used with AtomSDK.
/// This protocol allows external modules (e.g., AtomSDKAnalytics) to provide their own
/// analytics implementation without requiring the analytics
/// SDK to be bundled with AtomSDK. Implementations of this protocol should be provided via
/// separate modules that can be distributed via CocoaPods or Swift Package Manager.
/// <h2>Usage</h2>
/// To use a custom analytics provider:
/// <ol>
///   <li>
///     Create a separate module that implements this protocol (e.g., AtomSDKAnalytics)
///   </li>
///   <li>
///     Set the provider using setAnalyticsProvider: method
///   </li>
///   <li>
///     The provider will be used for all analytics events
///   </li>
/// </ol>
/// <h2>Important</h2>
/// If no provider is set, AtomSDK will silently ignore analytics events
/// without throwing any errors, allowing AtomSDK to work independently.
/// <h2>Swift and Objective-C Compatibility</h2>
/// This protocol is marked with @objc to ensure it can be used from both Swift and Objective-C code.
/// All methods are Objective-C compatible.
SWIFT_PROTOCOL("_TtP8AtomCore21AtomAnalyticsProvider_")
@protocol AtomAnalyticsProvider <NSObject>
/// Initialize the analytics provider with the given token and configuration.
/// \param token The analytics project token
///
/// \param loggingEnabled Whether logging should be enabled
///
/// \param trackAutomaticEvents Whether automatic events should be tracked
///
/// \param flushInterval The interval in seconds for flushing events to the server
///
- (void)initializeWithToken:(NSString * _Nonnull)token loggingEnabled:(BOOL)loggingEnabled trackAutomaticEvents:(BOOL)trackAutomaticEvents flushInterval:(double)flushInterval;
/// Track an event with optional properties.
/// \param event The event name to track
///
/// \param properties Optional dictionary of event properties. Values can be NSString, NSNumber, NSDate, NSArray, NSDictionary, or NSNull
///
- (void)trackWithEvent:(NSString * _Nonnull)event properties:(NSDictionary<NSString *, id> * _Nullable)properties;
/// Identify a user with a distinct ID.
/// \param distinctId The unique identifier for the user
///
- (void)identifyWithDistinctId:(NSString * _Nonnull)distinctId;
/// Flush pending events to the server immediately.
/// This should send any queued events to the analytics service.
- (void)flush;
/// Register super properties that will be sent with every event.
/// \param properties Dictionary of properties to be included with all events
///
- (void)registerSuperProperties:(NSDictionary<NSString *, id> * _Nonnull)properties;
@optional
/// Reset the analytics provider instance.
/// This should clear any cached data and reset the provider to its initial state.
- (void)reset;
@end

@class AtomProtocol;
@class AtomCustomAttributeObjects;
@class AtomChannelProtocolDns;
@class NSCoder;
/// Represents a Channel
/// <h1>Property</h1>
/// \code
///    AtomChannel
///
/// \endcode
SWIFT_CLASS("_TtC8AtomCore11AtomChannel")
@interface AtomChannel : NSObject <NSCoding>
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// Gets or sets the integer id of the channel. The valid Channel id is required for VPN Dialing.
/// <h1>Property</h1>
/// \code
///    channelId
///
/// \endcode
@property (nonatomic) NSInteger channelId;
/// Gets or sets the name of the channel.
/// <h1>Property</h1>
/// \code
///    name
///
/// \endcode
@property (nonatomic, copy) NSString * _Nullable name;
/// Gets or sets the web url of the channel.
/// <h1>Property</h1>
/// \code
///    channel_url
///
/// \endcode
@property (nonatomic, copy) NSString * _Nullable channel_url;
/// Gets or sets the Icon Url of the channel.
/// <h1>Property</h1>
/// \code
///    icon_url
///
/// \endcode
@property (nonatomic, copy) NSString * _Nullable icon;
/// Property to identify the code of country
/// <h1>Property</h1>
/// \code
///    country
///
/// \endcode
@property (nonatomic, copy) NSString * _Nullable country;
/// Property to identify the slug
/// <h1>Property</h1>
/// \code
///    slug
///
/// \endcode
@property (nonatomic, copy) NSString * _Nullable slug;
/// Gets the protocols supported by this channel.
/// <h1>Property</h1>
/// \code
///    protocol
///
/// \endcode
@property (nonatomic, copy) NSArray<AtomProtocol *> * _Nullable protocols;
/// The custom_attributes. Property to identify attributes of channel
/// <h1>Property</h1>
/// \code
///    custom_attributes
///
/// \endcode
@property (nonatomic, copy) NSArray<AtomCustomAttributeObjects *> * _Nullable custom_attributes;
/// The channelProtocolDns. Property to identify dns in protocols supported for the channel.
/// <h1>Property</h1>
/// \code
///    channelProtocolDns
///
/// \endcode
@property (nonatomic, copy) NSArray<AtomChannelProtocolDns *> * _Nullable channelProtocolDns;
/// The custom_attributes. Property to identify recommended protocol of country
/// <h1>Property</h1>
/// \code
///    recommendedProtocol
///
/// \endcode
@property (nonatomic, strong) AtomProtocol * _Nullable recommendedProtocol;
- (void)encodeWithCoder:(NSCoder * _Nonnull)coder;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end

@class AtomDns;
SWIFT_CLASS("_TtC8AtomCore22AtomChannelProtocolDns")
@interface AtomChannelProtocolDns : NSObject <NSCoding>
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, copy) NSString * _Nonnull id;
@property (nonatomic) NSInteger channelId;
@property (nonatomic, strong) AtomProtocol * _Nullable protocols;
@property (nonatomic, strong) AtomDns * _Nullable dns;
@property (nonatomic, copy) NSString * _Nonnull configuration_version;
@property (nonatomic) BOOL multiport_supported;
@property (nonatomic) NSInteger port_number;
@property (nonatomic) NSInteger api_endpoint;
- (void)encodeWithCoder:(NSCoder * _Nonnull)coder;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end

@class AtomDatacenters;
@class AtomCityProtocolDns;
SWIFT_CLASS("_TtC8AtomCore8AtomCity")
@interface AtomCity : NSObject <NSCoding>
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// Gets or sets the integer id of the city. The valid city id is required for VPN Dialing.
/// <h1>Property</h1>
/// \code
///    cityId
///
/// \endcode
@property (nonatomic) NSInteger cityId;
/// Gets or sets the name of the city.
/// <h1>Pproperty</h1>
/// \code
///    name
///
/// \endcode
@property (nonatomic, copy) NSString * _Nullable name;
/// Gets or sets the latitude of the country
/// <h1>Property</h1>
/// \code
///    latitude
///
/// \endcode
@property (nonatomic) double latitude;
/// Gets or sets the logitude of the country
/// <h1>Property</h1>
/// \code
///    longitude
///
/// \endcode
@property (nonatomic) double longitude;
/// Property to identify the code of country
/// <h1>Property</h1>
/// \code
///    country
///
/// \endcode
@property (nonatomic, copy) NSString * _Nullable country;
/// Gets or sets the country id of country with which city belongs. The valid country id is required for VPN Dialing.
/// <h1>Property</h1>
/// \code
///    countryId
///
/// \endcode
@property (nonatomic) NSInteger countryId;
/// Gets or sets the least time a packet takes to be sent to the server of this country plus the length of time it takes for an acknowledgment of that packet to be received at the client depending on user’s network conditions. Default value for this property is 0 when calling cities
/// <h1>Property</h1>
/// \code
///    latency
///
/// \endcode
@property (nonatomic) NSInteger latency;
/// Depending on the city. The values will be dependant upon the country provided for connection, representing the available data centers.
/// <h1>Property</h1>
/// \code
///    dataCenters
///
/// \endcode
@property (nonatomic, copy) NSArray<AtomDatacenters *> * _Nullable data_centers;
/// Gets the protocols supported by this city.
/// <h1>Property</h1>
/// \code
///    protocol
///
/// \endcode
@property (nonatomic, copy) NSArray<AtomProtocol *> * _Nullable protocols;
/// The custom_attributes. Property to identify attributes of city
/// <h1>Property</h1>
/// \code
///    custom_attributes
///
/// \endcode
@property (nonatomic, copy) NSArray<AtomCustomAttributeObjects *> * _Nullable custom_attributes;
/// The cityProtocolDns. Property to identify dns in protocols supported for the city.
/// <h1>Property</h1>
/// \code
///    cityProtocolDns
///
/// \endcode
@property (nonatomic, copy) NSArray<AtomCityProtocolDns *> * _Nullable cityProtocolDns;
/// The custom_attributes. Property to identify recommended protocol of city
/// <h1>Property</h1>
/// \code
///    recommendedProtocol
///
/// \endcode
@property (nonatomic, strong) AtomProtocol * _Nullable recommendedProtocol;
/// Depending on the country. The feautre list  will be dependant upon the country provided for connection
/// features
@property (nonatomic, copy) NSArray<NSString *> * _Nullable features;
- (void)encodeWithCoder:(NSCoder * _Nonnull)coder;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initFromJSON:(NSDictionary * _Nonnull)fromJSON OBJC_DESIGNATED_INITIALIZER;
- (void)setValue:(id _Nullable)value forUndefinedKey:(NSString * _Nonnull)key;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
@end

SWIFT_CLASS("_TtC8AtomCore19AtomCityProtocolDns")
@interface AtomCityProtocolDns : NSObject <NSCoding>
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, copy) NSString * _Nonnull id;
@property (nonatomic) NSInteger cityId;
@property (nonatomic, strong) AtomProtocol * _Nullable protocols;
@property (nonatomic, strong) AtomDns * _Nullable dns;
@property (nonatomic, copy) NSString * _Nonnull configuration_version;
@property (nonatomic) BOOL multiport_supported;
@property (nonatomic) NSInteger port_number;
@property (nonatomic) NSInteger api_endpoint;
- (void)encodeWithCoder:(NSCoder * _Nonnull)coder;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end

@class NSURL;
/// Represents a set of properties which contains the configuration settings to initialize the sdk.
/// <h1>Class</h1>
/// \code
///    AtomConfiguration
///
/// \endcode
SWIFT_CLASS("_TtC8AtomCore17AtomConfiguration")
@interface AtomConfiguration : NSObject
/// <ul>
///   <li>
///     @property secretKey
///   </li>
///   <li>
///     @discussion The Secret Key provided by ATOM at the time of subscription.
///   </li>
/// </ul>
@property (nonatomic, copy) NSString * _Nullable secretKey;
/// The base Url of all the requests to be made by the ATOM SDK. It is optional and can be managed through ATOM Console.
/// <h1>Property</h1>
/// \code
///    baseUrl
///
/// \endcode
@property (nonatomic, copy) NSURL * _Nullable baseUrl;
/// Name of the VPN adapter to be displayed.
/// <h1>Property</h1>
/// \code
///    vpnInterfaceName
///
/// \endcode
@property (nonatomic, copy) NSString * _Nullable vpnInterfaceName;
/// Bundle identifier for ovpn tunnel Provider app extension.
/// <h1>Property</h1>
/// \code
///    ovpn tunnelProviderBundleIdentifier
///
/// \endcode
@property (nonatomic, copy) NSString * _Nullable tunnelProviderBundleIdentifier;
/// Bundle identifier for wireguard tunnel Provider app extension.
/// <h1>Property</h1>
/// \code
///    wireguard tunnelProviderBundleIdentifier
///
/// \endcode
@property (nonatomic, copy) NSString * _Nullable wireGuardTunnelProviderBundleIdentifier;
/// The name of the app group in which the tunnel extension lives in.
/// <h1>Property</h1>
/// \code
///    appGroupIdentifier
///
/// \endcode
@property (nonatomic, copy) NSString * _Nullable appGroupIdentifier;
/// In order to enable OpenVPN log enable this bit. Default is false
/// <h1>Property</h1>
/// \code
///    enableVPNLogs
///
/// \endcode
@property (nonatomic) BOOL enableVPNLogs;
/// The persistVPNDetails used to store last  AtomProperties and AtomConnectionDetails.
/// <h1>Property</h1>
/// \code
///    persistVPNDetails
///
/// \endcode<h1>Available in AtomSDK ~> 3.0</h1>
@property (nonatomic) BOOL persistVPNDetails;
/// The disableAnalytics used to collect the Analytics of Atom SDK.
/// <h1>Property</h1>
/// disableAnalytics
@property (nonatomic) BOOL disableAnalytics;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

typedef SWIFT_ENUM(NSInteger, AtomCoreNetworkError, open) {
  AtomCoreNetworkErrorCoreParsingFailed = 4001,
  AtomCoreNetworkErrorCoreUrlNotFound = 4002,
  AtomCoreNetworkErrorCoreWebClientException = 4003,
  AtomCoreNetworkErrorCoreRequestFailed = 4006,
  AtomCoreNetworkErrorCoreRequestParameterEncodingFailed = 4007,
  AtomCoreNetworkErrorPingFailed = 7309,
};

@class AtomCountryProtocolDns;
/// Property to identify the code of country
/// <h1>Class</h1>
/// \code
///    AtomCountry
///
/// \endcode
SWIFT_CLASS("_TtC8AtomCore11AtomCountry")
@interface AtomCountry : NSObject <NSCoding, NSCopying>
- (id _Nonnull)copyWithZone:(struct _NSZone * _Nullable)zone SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// Property to identify the code of country
/// <h1>Property</h1>
/// \code
///    country
///
/// \endcode
@property (nonatomic, copy) NSString * _Nullable country;
/// Property to identify the name of the country
/// <h1>Property</h1>
/// \code
///    name
///
/// \endcode
@property (nonatomic, copy) NSString * _Nullable name;
/// Property to identify cities in that country
/// <h1>Property</h1>
/// \code
///    cities.
///
/// \endcode
@property (nonatomic, copy) NSArray<AtomCity *> * _Nullable cities;
/// Gets or sets the latitude of the country
/// <h1>Property</h1>
/// \code
///    latitude
///
/// \endcode
@property (nonatomic) double latitude;
/// Gets or sets the logitude of the country
/// <h1>Property</h1>
/// \code
///    longitude
///
/// \endcode
@property (nonatomic) double longitude;
/// Gets or sets the least time a packet takes to be sent to the server of this country plus the length of time it takes for an acknowledgment of that packet to be received at the client depending on user’s network conditions. Default value for this property is 0 when calling Countries
/// <h1>Property</h1>
/// \code
///    latency
///
/// \endcode
@property (nonatomic) NSInteger latency;
/// Gets or sets the ISO Alpha-2 Country code of the current country.
/// <h1>Property</h1>
/// \code
///    iso_code
///
/// \endcode
@property (nonatomic, copy) NSString * _Nullable iso_code;
/// The isSmartDialingSupported. Property to identify which country is Smart Country.
/// <h1>Property</h1>
/// \code
///    isSmartDialingSupported
///
/// \endcode
@property (nonatomic) BOOL isSmartDialingSupported;
/// The rank. Property to identify the rank of Country.
/// <h1>Property</h1>
/// \code
///    rank
///
/// \endcode
@property (nonatomic) NSInteger rank;
/// The isVirtual. Property to identify if country is physically or virtually avaiable.
/// <h1>Property</h1>
/// \code
///    isVirtual
///
/// \endcode
@property (nonatomic) BOOL isVirtual;
/// The acknowledgment_server. Property to identify acknowledgment server
/// <h1>Property</h1>
/// \code
///    acknowledgment_server
///
/// \endcode
@property (nonatomic, copy) NSString * _Nullable acknowledgement_server;
/// Depending on the country. The values will be dependant upon the country provided for connection, representing the available data centers.
/// <h1>Property</h1>
/// \code
///    dataCenters
///
/// \endcode
@property (nonatomic, copy) NSArray<AtomDatacenters *> * _Nullable dataCenters;
/// Gets the protocols supported by this country.
/// <h1>Property</h1>
/// \code
///    protocol
///
/// \endcode
@property (nonatomic, copy) NSArray<AtomProtocol *> * _Nullable protocols;
/// The custom_attributes. Property to identify attributes of country
/// <h1>Property</h1>
/// \code
///    custom_attributes
///
/// \endcode
@property (nonatomic, copy) NSArray<AtomCustomAttributeObjects *> * _Nullable custom_attributes;
/// The countryProtocolDns. Property to identify dns in protocols supported for the country.
/// <h1>Property</h1>
/// \code
///    countryProtocolDns
///
/// \endcode
@property (nonatomic, copy) NSArray<AtomCountryProtocolDns *> * _Nullable countryProtocolDns;
/// The custom_attributes. Property to identify recommended protocol of country
/// <h1>Property</h1>
/// \code
///    recommendedProtocol
///
/// \endcode
@property (nonatomic, strong) AtomProtocol * _Nullable recommendedProtocol;
/// Depending on the country. The feautre list  will be dependant upon the country provided for connection
/// features
@property (nonatomic, copy) NSArray<NSString *> * _Nullable features;
- (void)encodeWithCoder:(NSCoder * _Nonnull)coder;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initFromJSON:(NSDictionary * _Nonnull)fromJSON OBJC_DESIGNATED_INITIALIZER;
- (void)setValue:(id _Nullable)value forUndefinedKey:(NSString * _Nonnull)key;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
@end

SWIFT_CLASS("_TtC8AtomCore22AtomCountryProtocolDns")
@interface AtomCountryProtocolDns : NSObject <NSCoding>
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, copy) NSString * _Nullable id;
@property (nonatomic, copy) NSString * _Nullable country;
@property (nonatomic, strong) AtomProtocol * _Nullable protocols;
@property (nonatomic, strong) AtomDns * _Nullable dns;
@property (nonatomic, copy) NSString * _Nonnull configuration_version;
@property (nonatomic) BOOL multiport_supported;
@property (nonatomic) NSInteger port_number;
@property (nonatomic) NSInteger api_endpoint;
- (void)encodeWithCoder:(NSCoder * _Nonnull)coder;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end

@class AtomMasterCustomAttributes;
SWIFT_CLASS("_TtC8AtomCore26AtomCustomAttributeObjects")
@interface AtomCustomAttributeObjects : NSObject <NSCoding>
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, copy) NSString * _Nullable customAttributeId;
@property (nonatomic, strong) AtomMasterCustomAttributes * _Nonnull masterCustomAttribute;
@property (nonatomic, copy) NSString * _Nullable value;
- (void)encodeWithCoder:(NSCoder * _Nonnull)coder;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end

SWIFT_CLASS("_TtC8AtomCore15AtomDatacenters")
@interface AtomDatacenters : NSObject <NSCoding>
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic) NSInteger dataCenterId;
@property (nonatomic, copy) NSString * _Nullable name;
@property (nonatomic, copy) NSString * _Nullable ip;
@property (nonatomic, copy) NSString * _Nullable hostname;
@property (nonatomic) NSInteger latency;
@property (nonatomic, copy) NSArray<AtomCustomAttributeObjects *> * _Nullable custom_attributes;
- (nonnull instancetype)initFromJSON:(NSDictionary * _Nonnull)fromJSON OBJC_DESIGNATED_INITIALIZER;
- (void)encodeWithCoder:(NSCoder * _Nonnull)coder;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
- (void)setValue:(id _Nullable)value forUndefinedKey:(NSString * _Nonnull)key;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
@end

@class NSNumber;
SWIFT_CLASS("_TtC8AtomCore25AtomDedicatedIPServerPing")
@interface AtomDedicatedIPServerPing : NSObject
- (nonnull instancetype)initWithServerAddress:(NSString * _Nonnull)serverAddress OBJC_DESIGNATED_INITIALIZER;
/// Property to identify the address of the server
/// <h1>Property</h1>
/// serverAddress
@property (nonatomic, copy) NSString * _Nullable serverAddress;
/// Property to identify the serverIP of the server
/// <h1>Property</h1>
/// serverIP
@property (nonatomic, copy) NSString * _Nullable serverIP;
/// Property to identify the latency of the server
/// <h1>Property</h1>
/// latency
@property (nonatomic, strong) NSNumber * _Nullable latency;
/// Property to identify the unit of the latency
/// <h1>Property</h1>
/// \code
///    unit
///
/// \endcode
@property (nonatomic, copy) NSString * _Nullable unit;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

SWIFT_CLASS("_TtC8AtomCore18AtomDefaultAccount")
@interface AtomDefaultAccount : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, copy) NSString * _Nullable id;
@property (nonatomic, copy) NSString * _Nullable vpn_username;
@property (nonatomic, copy) NSString * _Nullable vpn_password;
@end

SWIFT_CLASS("_TtC8AtomCore7AtomDns")
@interface AtomDns : NSObject <NSCoding>
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, copy) NSString * _Nullable hostname;
@property (nonatomic, copy) NSString * _Nullable type;
@property (nonatomic) NSInteger dnsid;
@property (nonatomic, copy) NSString * _Nullable acknowledgementServer;
@property (nonatomic, copy) NSString * _Nullable multiportRange;
@property (nonatomic, copy) NSString * _Nullable configurationVersion;
@property (nonatomic) NSInteger portNumber;
@property (nonatomic) BOOL isMultiport;
@property (nonatomic, copy) NSString * _Nullable ipTranslation;
@property (nonatomic, copy) NSArray<NSString *> * _Nullable tags;
- (void)encodeWithCoder:(NSCoder * _Nonnull)coder;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
@end

/// These properties can be used to identify SDK whether the user is allowed to park in any specific app experiment
/// <h1>Class</h1>
/// AtomExperimentProperties
SWIFT_CLASS("_TtC8AtomCore24AtomExperimentProperties")
@interface AtomExperimentProperties : NSObject
/// This flag will indicate SDK, whether the user is eligible to particate in speed test experiment. If the value is <b>true</b>, it will allow SDK to mark user as experimented user and respectively.
@property (nonatomic) BOOL isExperimentedUser;
/// Network speed of the user before VPN connection
/// <h1>Property</h1>
/// baseSpeed
@property (nonatomic) double baseSpeed;
/// The source of provided base speed
/// <h1>Property</h1>
/// baseSpeedSource
@property (nonatomic, copy) NSString * _Nullable baseSpeedSource;
- (nonnull instancetype)initWithIsExperimentedUser:(BOOL)isExperimentedUser baseSpeed:(double)baseSpeed;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class AtomPackages;
@class AtomPurposes;
SWIFT_CLASS("_TtC8AtomCore10AtomGroups")
@interface AtomGroups : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, copy) NSString * _Nonnull groupId;
@property (nonatomic, copy) NSString * _Nullable name;
@property (nonatomic, copy) NSString * _Nonnull parent_group_id;
@property (nonatomic, copy) NSArray<AtomCustomAttributeObjects *> * _Nullable custom_attributes;
@property (nonatomic, copy) NSArray<AtomProtocol *> * _Nullable protocols;
@property (nonatomic, copy) NSArray<AtomChannel *> * _Nullable channels;
@property (nonatomic, copy) NSArray<AtomCountry *> * _Nullable countries;
@property (nonatomic, copy) NSArray<AtomPackages *> * _Nullable packages;
@property (nonatomic, copy) NSArray<AtomCity *> * _Nullable cities;
@property (nonatomic, copy) NSArray<AtomPurposes *> * _Nullable purposes;
@end

@class Server;
SWIFT_CLASS("_TtC8AtomCore12AtomLocation")
@interface AtomLocation : NSObject <NSCoding>
- (void)encodeWithCoder:(NSCoder * _Nonnull)coder;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCountryObject:(AtomCountry * _Nonnull)countryObject cityObject:(AtomCity * _Nullable)cityObject ipAddress:(NSString * _Nullable)ipAddress OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, strong) AtomCountry * _Nullable country;
@property (nonatomic, strong) AtomCity * _Nullable city;
@property (nonatomic, copy) NSString * _Nullable ip;
@property (nonatomic, strong) Server * _Nullable server;
- (nonnull instancetype)initFromJSON:(NSDictionary * _Nonnull)fromJSON OBJC_DESIGNATED_INITIALIZER;
- (void)setValue:(id _Nullable)value forUndefinedKey:(NSString * _Nonnull)key;
- (void)setValue:(id _Nullable)value forKey:(NSString * _Nonnull)forKey;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

SWIFT_CLASS("_TtC8AtomCore26AtomMasterCustomAttributes")
@interface AtomMasterCustomAttributes : NSObject <NSCoding>
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, copy) NSString * _Nullable id;
@property (nonatomic, copy) NSString * _Nullable attribute;
@property (nonatomic, copy) NSString * _Nullable datatype;
- (void)encodeWithCoder:(NSCoder * _Nonnull)coder;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end

@class AtomOvpnConfigurationProtocol;
SWIFT_CLASS("_TtC8AtomCore21AtomOvpnConfiguration")
@interface AtomOvpnConfiguration : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, copy) NSString * _Nullable configuration_version;
@property (nonatomic, copy) NSArray<AtomOvpnConfigurationProtocol *> * _Nullable protocols;
@end

SWIFT_CLASS("_TtC8AtomCore29AtomOvpnConfigurationProtocol")
@interface AtomOvpnConfigurationProtocol : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, copy) NSString * _Nullable ovpnConfigurationId;
@property (nonatomic, copy) NSString * _Nullable configuration;
@property (nonatomic, copy) NSString * _Nullable configuration_version;
@property (nonatomic, strong) AtomProtocol * _Nonnull protocols;
@end

SWIFT_CLASS("_TtC8AtomCore12AtomPackages")
@interface AtomPackages : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, copy) NSString * _Nonnull packageId;
@property (nonatomic, copy) NSString * _Nullable name;
@property (nonatomic, copy) NSString * _Nonnull multi_login;
@property (nonatomic, copy) NSString * _Nonnull session_limit;
@property (nonatomic, copy) NSString * _Nonnull accounts;
@property (nonatomic, copy) NSString * _Nonnull concurrent_users;
@property (nonatomic) NSInteger bandwidth;
@property (nonatomic, copy) NSArray<AtomProtocol *> * _Nullable protocols;
@property (nonatomic, copy) NSArray<AtomChannel *> * _Nullable channels;
@property (nonatomic, copy) NSArray<AtomCountry *> * _Nullable countries;
@property (nonatomic, copy) NSArray<AtomPurposes *> * _Nullable purposes;
@property (nonatomic, copy) NSArray<AtomCity *> * _Nullable cities;
@property (nonatomic, copy) NSArray<AtomCustomAttributeObjects *> * _Nullable custom_attributes;
@end

SWIFT_CLASS("_TtC8AtomCore12AtomProtocol")
@interface AtomProtocol : NSObject <NSCoding>
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// Gets or sets the name the protocol.
/// <h1>Property</h1>
/// \code
///    name
///
/// \endcode
@property (nonatomic, copy) NSString * _Nullable name;
/// Get or sets the protocol
/// <h1>Property</h1>
/// \code
///    protocol
///
/// \endcode
@property (nonatomic, copy) NSString * _Nullable protocol;
/// Get or sets the port_number
/// <h1>Property</h1>
/// \code
///    port_number
///
/// \endcode
@property (nonatomic) NSInteger port_number;
/// Get or sets the multiport_range
/// <h1>Property</h1>
/// \code
///    multiport_range
///
/// \endcode
@property (nonatomic, copy) NSString * _Nullable multiport_range;
/// Get or sets the configuration
/// <h1>Property</h1>
/// \code
///    configuration
///
/// \endcode
@property (nonatomic, copy) NSString * _Nullable configuration;
/// Get or sets the multiport_supported
/// <h1>Property</h1>
/// \code
///    multiport_supported
///
/// \endcode
@property (nonatomic) BOOL multiport_supported;
/// The dns. Depending on the protocol.
/// <h1>Property</h1>
/// \code
///    dns
///
/// \endcode
@property (nonatomic, copy) NSArray<AtomDns *> * _Nullable dns;
/// The protocolSwitch. Depending on the protocol.
/// <h1>Property</h1>
/// \code
///    protocolSwitch
///
/// \endcode
@property (nonatomic, copy) NSArray<AtomProtocol *> * _Nullable protocolSwitch;
/// The custom_attributes. Property to identify attributes of city
/// <h1>Property</h1>
/// \code
///    custom_attributes
///
/// \endcode
@property (nonatomic, copy) NSArray<AtomCustomAttributeObjects *> * _Nullable custom_attributes;
- (void)encodeWithCoder:(NSCoder * _Nonnull)coder;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end

SWIFT_CLASS("_TtC8AtomCore22AtomPurposeProtocolDns")
@interface AtomPurposeProtocolDns : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, copy) NSString * _Nonnull id;
@property (nonatomic) NSInteger purposeId;
@property (nonatomic, strong) AtomProtocol * _Nullable protocols;
@property (nonatomic, strong) AtomDns * _Nullable dns;
@property (nonatomic, copy) NSString * _Nonnull configuration_version;
@property (nonatomic) BOOL multiport_supported;
@property (nonatomic) NSInteger port_number;
@property (nonatomic) NSInteger api_endpoint;
@end

SWIFT_CLASS("_TtC8AtomCore12AtomPurposes")
@interface AtomPurposes : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic) NSInteger purposeId;
@property (nonatomic, copy) NSString * _Nullable name;
@property (nonatomic, copy) NSArray<AtomCountry *> * _Nullable countries;
@property (nonatomic, copy) NSArray<AtomProtocol *> * _Nullable protocols;
@property (nonatomic, copy) NSArray<AtomPurposeProtocolDns *> * _Nullable purposeProtocolDns;
@property (nonatomic, copy) NSArray<AtomCustomAttributeObjects *> * _Nullable custom_attributes;
@end

SWIFT_CLASS("_TtC8AtomCore12AtomReseller")
@interface AtomReseller : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic) NSInteger resellerId;
@property (nonatomic, copy) NSString * _Nullable resellerUId;
@end

typedef SWIFT_ENUM(NSInteger, AtomSDKError, open) {
  AtomSDKErrorSecretKeyRequired = 5001,
  AtomSDKErrorAccessTokenRequestFailed = 5002,
  AtomSDKErrorAccessTokenGeneralError = 5003,
  AtomSDKErrorAccessTokenJsonNotSerialized = 5005,
};

@class AtomSmartConnectProtocolDns;
SWIFT_CLASS("_TtC8AtomCore16AtomSmartConnect")
@interface AtomSmartConnect : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic) NSInteger id;
@property (nonatomic, copy) NSString * _Nullable name;
@property (nonatomic, copy) NSString * _Nullable title;
@property (nonatomic, copy) NSArray<AtomProtocol *> * _Nullable protocols;
@property (nonatomic, copy) NSArray<AtomSmartConnectProtocolDns *> * _Nullable smartConnectProtocolDns;
@property (nonatomic, copy) NSString * _Nullable host;
@property (nonatomic, copy) NSString * _Nullable configurationVersion;
@property (nonatomic, copy) NSString * _Nullable dnsType;
@property (nonatomic, copy) NSString * _Nullable protocol;
@property (nonatomic) NSInteger protocolNumber;
@property (nonatomic) BOOL isMultiport;
@property (nonatomic, copy) NSArray<NSString *> * _Nullable tags;
@end

SWIFT_CLASS("_TtC8AtomCore27AtomSmartConnectProtocolDns")
@interface AtomSmartConnectProtocolDns : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, copy) NSString * _Nonnull id;
@property (nonatomic) NSInteger smartConnectId;
@property (nonatomic, strong) AtomProtocol * _Nullable protocols;
@property (nonatomic, strong) AtomDns * _Nullable dns;
@property (nonatomic) NSInteger api_endpoint;
@property (nonatomic, copy) NSString * _Nonnull configuration_version;
@property (nonatomic) BOOL multiport_supported;
@property (nonatomic) NSInteger port_number;
@end

typedef SWIFT_ENUM(NSInteger, AtomSmartConnectTag, open) {
  AtomSmartConnectTagAutomatic = 0,
  AtomSmartConnectTagFileSharing = 1,
  AtomSmartConnectTagFreeFileSharing = 2,
  AtomSmartConnectTagAutomaticFileSharing = 3,
  AtomSmartConnectTagFreeUsers = 4,
  AtomSmartConnectTagNatted = 5,
  AtomSmartConnectTagNattedFileSharing = 6,
  AtomSmartConnectTagPaid = 7,
  AtomSmartConnectTagAvfFileSharing = 8,
  AtomSmartConnectTagAvfSecurity = 9,
};

SWIFT_PROTOCOL("_TtP8AtomCore15ManagerProtocol_")
@protocol ManagerProtocol
@property (nonatomic, strong) AtomConfiguration * _Nullable atomConfiguration;
@property (nonatomic, strong) AccessTokenModel * _Nullable accessToken;
@property (nonatomic, copy) NSString * _Nullable activeBaseUrl;
@property (nonatomic, strong) ApiBaseUrlModel * _Nullable apiUrl;
@end

SWIFT_PROTOCOL("_TtP8AtomCore12PingProtocol_")
@protocol PingProtocol
- (void)getOptimizedCountriesWithResponse:(void (^ _Nonnull)(NSArray<AtomCountry *> * _Nullable, NSError * _Nullable))response;
- (void)getOptimizedCitiesWithResponse:(void (^ _Nonnull)(NSArray<AtomCity *> * _Nullable, NSError * _Nullable))response;
- (void)getOptimizedDataCentersWithResponse:(void (^ _Nonnull)(NSArray<AtomDatacenters *> * _Nullable, NSError * _Nullable))response;
@end

@interface NSArray<ObjectType> (SWIFT_EXTENSION(AtomCore)) <PingProtocol>
- (void)getOptimizedCountriesWithResponse:(void (^ _Nonnull)(NSArray<AtomCountry *> * _Nullable, NSError * _Nullable))response;
- (void)getOptimizedCitiesWithResponse:(void (^ _Nonnull)(NSArray<AtomCity *> * _Nullable, NSError * _Nullable))response;
- (void)getOptimizedDataCentersWithResponse:(void (^ _Nonnull)(NSArray<AtomDatacenters *> * _Nullable, NSError * _Nullable))response;
@end

@interface NSError (SWIFT_EXTENSION(AtomCore))
+ (NSError * _Nullable)errorWithResponseParams:(NSDictionary * _Nonnull)responseParams domain:(NSString * _Nonnull)domain SWIFT_WARN_UNUSED_RESULT;
+ (NSError * _Nullable)errorWithCode:(NSInteger)code message:(NSString * _Nonnull)message domain:(NSString * _Nonnull)domain SWIFT_WARN_UNUSED_RESULT;
+ (NSError * _Nullable)errorWithCode:(NSInteger)code errorMessage:(NSString * _Nonnull)errorMessage andFailureMessage:(NSString * _Nonnull)andFailureMessage domain:(NSString * _Nonnull)domain SWIFT_WARN_UNUSED_RESULT;
@end

SWIFT_CLASS("_TtC8AtomCore6Server")
@interface Server : NSObject <NSCoding>
@property (nonatomic, copy) NSString * _Nullable nasIdentifier;
- (void)encodeWithCoder:(NSCoder * _Nonnull)coder;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
- (void)setValue:(id _Nullable)value forKey:(NSString * _Nonnull)forKey;
- (void)setValue:(id _Nullable)value forUndefinedKey:(NSString * _Nonnull)key;
- (nonnull instancetype)initFromJSON:(NSDictionary * _Nonnull)fromJSON OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

SWIFT_CLASS("_TtC8AtomCore21SmartConnectTagHelper")
@interface SmartConnectTagHelper : NSObject
+ (NSString * _Nonnull)getStringFrom:(enum AtomSmartConnectTag)from SWIFT_WARN_UNUSED_RESULT;
+ (enum AtomSmartConnectTag)getTagFromString:(NSString * _Nonnull)from SWIFT_WARN_UNUSED_RESULT;
+ (enum AtomSmartConnectTag)getTagFromInt:(NSInteger)from SWIFT_WARN_UNUSED_RESULT;
+ (NSString * _Nonnull)getTagValueFromInt:(NSNumber * _Nonnull)from SWIFT_WARN_UNUSED_RESULT;
+ (NSArray<NSNumber *> * _Nonnull)getAvailableTags SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

#endif
#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#if defined(__cplusplus)
#endif
#pragma clang diagnostic pop
#endif

#elif defined(__x86_64__) && __x86_64__
// Generated by Apple Swift version 6.1.2 effective-5.10 (swiftlang-6.1.2.1.2 clang-1700.0.13.5)
#ifndef ATOMCORE_SWIFT_H
#define ATOMCORE_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#if defined(__OBJC__)
#include <Foundation/Foundation.h>
#endif
#if defined(__cplusplus)
#include <cstdint>
#include <cstddef>
#include <cstdbool>
#include <cstring>
#include <stdlib.h>
#include <new>
#include <type_traits>
#else
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#endif
#if defined(__cplusplus)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wnon-modular-include-in-framework-module"
#if defined(__arm64e__) && __has_include(<ptrauth.h>)
# include <ptrauth.h>
#else
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wreserved-macro-identifier"
# ifndef __ptrauth_swift_value_witness_function_pointer
#  define __ptrauth_swift_value_witness_function_pointer(x)
# endif
# ifndef __ptrauth_swift_class_method_pointer
#  define __ptrauth_swift_class_method_pointer(x)
# endif
#pragma clang diagnostic pop
#endif
#pragma clang diagnostic pop
#endif

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef unsigned char char8_t;
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...) 
# endif
#endif
#if !defined(SWIFT_RUNTIME_NAME)
# if __has_attribute(objc_runtime_name)
#  define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
# else
#  define SWIFT_RUNTIME_NAME(X) 
# endif
#endif
#if !defined(SWIFT_COMPILE_NAME)
# if __has_attribute(swift_name)
#  define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
# else
#  define SWIFT_COMPILE_NAME(X) 
# endif
#endif
#if !defined(SWIFT_METHOD_FAMILY)
# if __has_attribute(objc_method_family)
#  define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
# else
#  define SWIFT_METHOD_FAMILY(X) 
# endif
#endif
#if !defined(SWIFT_NOESCAPE)
# if __has_attribute(noescape)
#  define SWIFT_NOESCAPE __attribute__((noescape))
# else
#  define SWIFT_NOESCAPE 
# endif
#endif
#if !defined(SWIFT_RELEASES_ARGUMENT)
# if __has_attribute(ns_consumed)
#  define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
# else
#  define SWIFT_RELEASES_ARGUMENT 
# endif
#endif
#if !defined(SWIFT_WARN_UNUSED_RESULT)
# if __has_attribute(warn_unused_result)
#  define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
# else
#  define SWIFT_WARN_UNUSED_RESULT 
# endif
#endif
#if !defined(SWIFT_NORETURN)
# if __has_attribute(noreturn)
#  define SWIFT_NORETURN __attribute__((noreturn))
# else
#  define SWIFT_NORETURN 
# endif
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA 
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA 
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA 
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif
#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif
#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER 
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility) 
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED_OBJC)
# if __has_feature(attribute_diagnose_if_objc)
#  define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
# else
#  define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
# endif
#endif
#if defined(__OBJC__)
#if !defined(IBSegueAction)
# define IBSegueAction 
#endif
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if !defined(SWIFT_CALL)
# define SWIFT_CALL __attribute__((swiftcall))
#endif
#if !defined(SWIFT_INDIRECT_RESULT)
# define SWIFT_INDIRECT_RESULT __attribute__((swift_indirect_result))
#endif
#if !defined(SWIFT_CONTEXT)
# define SWIFT_CONTEXT __attribute__((swift_context))
#endif
#if !defined(SWIFT_ERROR_RESULT)
# define SWIFT_ERROR_RESULT __attribute__((swift_error_result))
#endif
#if defined(__cplusplus)
# define SWIFT_NOEXCEPT noexcept
#else
# define SWIFT_NOEXCEPT 
#endif
#if !defined(SWIFT_C_INLINE_THUNK)
# if __has_attribute(always_inline)
# if __has_attribute(nodebug)
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline)) __attribute__((nodebug))
# else
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline))
# endif
# else
#  define SWIFT_C_INLINE_THUNK inline
# endif
#endif
#if defined(_WIN32)
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL __declspec(dllimport)
#endif
#else
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL 
#endif
#endif
#if defined(__OBJC__)
#if __has_feature(objc_modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import Foundation;
@import ObjectiveC;
#endif

#endif
#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"
#pragma clang diagnostic ignored "-Wunsafe-buffer-usage"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="AtomCore",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

#if defined(__OBJC__)

@class NSString;
SWIFT_CLASS("_TtC8AtomCore16AccessTokenModel")
@interface AccessTokenModel : NSObject
@property (nonatomic, copy) NSString * _Nullable accessToken;
@property (nonatomic, copy) NSString * _Nullable refreshToken;
@property (nonatomic, copy) NSString * _Nullable resellerId;
@property (nonatomic, copy) NSString * _Nullable resellerUid;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

SWIFT_CLASS("_TtC8AtomCore15ApiBaseUrlModel")
@interface ApiBaseUrlModel : NSObject
@property (nonatomic, copy) NSString * _Nullable base_url;
@property (nonatomic, copy) NSString * _Nullable secondary_base_url;
@property (nonatomic, copy) NSString * _Nullable auth_accessToken;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

SWIFT_CLASS("_TtC8AtomCore18AppHelperFunctions")
@interface AppHelperFunctions : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class NSBundle;
@interface AppHelperFunctions (SWIFT_EXTENSION(AtomCore))
/// This method will return the user agent to be used in all network request
/// \param bundle bundle for the class name for framework
///
///
/// returns:
/// String to be used in User-Agent
- (NSString * _Nullable)getUserAgentForNetworkRequestWithBundle:(NSBundle * _Nonnull)bundle SWIFT_WARN_UNUSED_RESULT;
/// This method will return the display name of the passed bundle
/// \param bundle bundle for class name or main
///
///
/// returns:
/// disply name of the passed bundle
- (NSString * _Nullable)displayName:(NSBundle * _Nonnull)bundle SWIFT_WARN_UNUSED_RESULT;
/// This method will return the version number of the passed bundle
/// \param bundle bundle for class name or main
///
///
/// returns:
/// version number of the passed bundle
- (NSString * _Nullable)versionNumber:(NSBundle * _Nullable)bundle SWIFT_WARN_UNUSED_RESULT;
/// This method will return the build number of the passed bundle
/// \param bundle bundle for class name or main
///
///
/// returns:
/// build number of the passed bundle
- (NSString * _Nullable)buildNumber:(NSBundle * _Nullable)bundle SWIFT_WARN_UNUSED_RESULT;
@end

/// Protocol for analytics providers that can be used with AtomSDK.
/// This protocol allows external modules (e.g., AtomSDKAnalytics) to provide their own
/// analytics implementation without requiring the analytics
/// SDK to be bundled with AtomSDK. Implementations of this protocol should be provided via
/// separate modules that can be distributed via CocoaPods or Swift Package Manager.
/// <h2>Usage</h2>
/// To use a custom analytics provider:
/// <ol>
///   <li>
///     Create a separate module that implements this protocol (e.g., AtomSDKAnalytics)
///   </li>
///   <li>
///     Set the provider using setAnalyticsProvider: method
///   </li>
///   <li>
///     The provider will be used for all analytics events
///   </li>
/// </ol>
/// <h2>Important</h2>
/// If no provider is set, AtomSDK will silently ignore analytics events
/// without throwing any errors, allowing AtomSDK to work independently.
/// <h2>Swift and Objective-C Compatibility</h2>
/// This protocol is marked with @objc to ensure it can be used from both Swift and Objective-C code.
/// All methods are Objective-C compatible.
SWIFT_PROTOCOL("_TtP8AtomCore21AtomAnalyticsProvider_")
@protocol AtomAnalyticsProvider <NSObject>
/// Initialize the analytics provider with the given token and configuration.
/// \param token The analytics project token
///
/// \param loggingEnabled Whether logging should be enabled
///
/// \param trackAutomaticEvents Whether automatic events should be tracked
///
/// \param flushInterval The interval in seconds for flushing events to the server
///
- (void)initializeWithToken:(NSString * _Nonnull)token loggingEnabled:(BOOL)loggingEnabled trackAutomaticEvents:(BOOL)trackAutomaticEvents flushInterval:(double)flushInterval;
/// Track an event with optional properties.
/// \param event The event name to track
///
/// \param properties Optional dictionary of event properties. Values can be NSString, NSNumber, NSDate, NSArray, NSDictionary, or NSNull
///
- (void)trackWithEvent:(NSString * _Nonnull)event properties:(NSDictionary<NSString *, id> * _Nullable)properties;
/// Identify a user with a distinct ID.
/// \param distinctId The unique identifier for the user
///
- (void)identifyWithDistinctId:(NSString * _Nonnull)distinctId;
/// Flush pending events to the server immediately.
/// This should send any queued events to the analytics service.
- (void)flush;
/// Register super properties that will be sent with every event.
/// \param properties Dictionary of properties to be included with all events
///
- (void)registerSuperProperties:(NSDictionary<NSString *, id> * _Nonnull)properties;
@optional
/// Reset the analytics provider instance.
/// This should clear any cached data and reset the provider to its initial state.
- (void)reset;
@end

@class AtomProtocol;
@class AtomCustomAttributeObjects;
@class AtomChannelProtocolDns;
@class NSCoder;
/// Represents a Channel
/// <h1>Property</h1>
/// \code
///    AtomChannel
///
/// \endcode
SWIFT_CLASS("_TtC8AtomCore11AtomChannel")
@interface AtomChannel : NSObject <NSCoding>
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// Gets or sets the integer id of the channel. The valid Channel id is required for VPN Dialing.
/// <h1>Property</h1>
/// \code
///    channelId
///
/// \endcode
@property (nonatomic) NSInteger channelId;
/// Gets or sets the name of the channel.
/// <h1>Property</h1>
/// \code
///    name
///
/// \endcode
@property (nonatomic, copy) NSString * _Nullable name;
/// Gets or sets the web url of the channel.
/// <h1>Property</h1>
/// \code
///    channel_url
///
/// \endcode
@property (nonatomic, copy) NSString * _Nullable channel_url;
/// Gets or sets the Icon Url of the channel.
/// <h1>Property</h1>
/// \code
///    icon_url
///
/// \endcode
@property (nonatomic, copy) NSString * _Nullable icon;
/// Property to identify the code of country
/// <h1>Property</h1>
/// \code
///    country
///
/// \endcode
@property (nonatomic, copy) NSString * _Nullable country;
/// Property to identify the slug
/// <h1>Property</h1>
/// \code
///    slug
///
/// \endcode
@property (nonatomic, copy) NSString * _Nullable slug;
/// Gets the protocols supported by this channel.
/// <h1>Property</h1>
/// \code
///    protocol
///
/// \endcode
@property (nonatomic, copy) NSArray<AtomProtocol *> * _Nullable protocols;
/// The custom_attributes. Property to identify attributes of channel
/// <h1>Property</h1>
/// \code
///    custom_attributes
///
/// \endcode
@property (nonatomic, copy) NSArray<AtomCustomAttributeObjects *> * _Nullable custom_attributes;
/// The channelProtocolDns. Property to identify dns in protocols supported for the channel.
/// <h1>Property</h1>
/// \code
///    channelProtocolDns
///
/// \endcode
@property (nonatomic, copy) NSArray<AtomChannelProtocolDns *> * _Nullable channelProtocolDns;
/// The custom_attributes. Property to identify recommended protocol of country
/// <h1>Property</h1>
/// \code
///    recommendedProtocol
///
/// \endcode
@property (nonatomic, strong) AtomProtocol * _Nullable recommendedProtocol;
- (void)encodeWithCoder:(NSCoder * _Nonnull)coder;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end

@class AtomDns;
SWIFT_CLASS("_TtC8AtomCore22AtomChannelProtocolDns")
@interface AtomChannelProtocolDns : NSObject <NSCoding>
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, copy) NSString * _Nonnull id;
@property (nonatomic) NSInteger channelId;
@property (nonatomic, strong) AtomProtocol * _Nullable protocols;
@property (nonatomic, strong) AtomDns * _Nullable dns;
@property (nonatomic, copy) NSString * _Nonnull configuration_version;
@property (nonatomic) BOOL multiport_supported;
@property (nonatomic) NSInteger port_number;
@property (nonatomic) NSInteger api_endpoint;
- (void)encodeWithCoder:(NSCoder * _Nonnull)coder;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end

@class AtomDatacenters;
@class AtomCityProtocolDns;
SWIFT_CLASS("_TtC8AtomCore8AtomCity")
@interface AtomCity : NSObject <NSCoding>
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// Gets or sets the integer id of the city. The valid city id is required for VPN Dialing.
/// <h1>Property</h1>
/// \code
///    cityId
///
/// \endcode
@property (nonatomic) NSInteger cityId;
/// Gets or sets the name of the city.
/// <h1>Pproperty</h1>
/// \code
///    name
///
/// \endcode
@property (nonatomic, copy) NSString * _Nullable name;
/// Gets or sets the latitude of the country
/// <h1>Property</h1>
/// \code
///    latitude
///
/// \endcode
@property (nonatomic) double latitude;
/// Gets or sets the logitude of the country
/// <h1>Property</h1>
/// \code
///    longitude
///
/// \endcode
@property (nonatomic) double longitude;
/// Property to identify the code of country
/// <h1>Property</h1>
/// \code
///    country
///
/// \endcode
@property (nonatomic, copy) NSString * _Nullable country;
/// Gets or sets the country id of country with which city belongs. The valid country id is required for VPN Dialing.
/// <h1>Property</h1>
/// \code
///    countryId
///
/// \endcode
@property (nonatomic) NSInteger countryId;
/// Gets or sets the least time a packet takes to be sent to the server of this country plus the length of time it takes for an acknowledgment of that packet to be received at the client depending on user’s network conditions. Default value for this property is 0 when calling cities
/// <h1>Property</h1>
/// \code
///    latency
///
/// \endcode
@property (nonatomic) NSInteger latency;
/// Depending on the city. The values will be dependant upon the country provided for connection, representing the available data centers.
/// <h1>Property</h1>
/// \code
///    dataCenters
///
/// \endcode
@property (nonatomic, copy) NSArray<AtomDatacenters *> * _Nullable data_centers;
/// Gets the protocols supported by this city.
/// <h1>Property</h1>
/// \code
///    protocol
///
/// \endcode
@property (nonatomic, copy) NSArray<AtomProtocol *> * _Nullable protocols;
/// The custom_attributes. Property to identify attributes of city
/// <h1>Property</h1>
/// \code
///    custom_attributes
///
/// \endcode
@property (nonatomic, copy) NSArray<AtomCustomAttributeObjects *> * _Nullable custom_attributes;
/// The cityProtocolDns. Property to identify dns in protocols supported for the city.
/// <h1>Property</h1>
/// \code
///    cityProtocolDns
///
/// \endcode
@property (nonatomic, copy) NSArray<AtomCityProtocolDns *> * _Nullable cityProtocolDns;
/// The custom_attributes. Property to identify recommended protocol of city
/// <h1>Property</h1>
/// \code
///    recommendedProtocol
///
/// \endcode
@property (nonatomic, strong) AtomProtocol * _Nullable recommendedProtocol;
/// Depending on the country. The feautre list  will be dependant upon the country provided for connection
/// features
@property (nonatomic, copy) NSArray<NSString *> * _Nullable features;
- (void)encodeWithCoder:(NSCoder * _Nonnull)coder;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initFromJSON:(NSDictionary * _Nonnull)fromJSON OBJC_DESIGNATED_INITIALIZER;
- (void)setValue:(id _Nullable)value forUndefinedKey:(NSString * _Nonnull)key;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
@end

SWIFT_CLASS("_TtC8AtomCore19AtomCityProtocolDns")
@interface AtomCityProtocolDns : NSObject <NSCoding>
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, copy) NSString * _Nonnull id;
@property (nonatomic) NSInteger cityId;
@property (nonatomic, strong) AtomProtocol * _Nullable protocols;
@property (nonatomic, strong) AtomDns * _Nullable dns;
@property (nonatomic, copy) NSString * _Nonnull configuration_version;
@property (nonatomic) BOOL multiport_supported;
@property (nonatomic) NSInteger port_number;
@property (nonatomic) NSInteger api_endpoint;
- (void)encodeWithCoder:(NSCoder * _Nonnull)coder;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end

@class NSURL;
/// Represents a set of properties which contains the configuration settings to initialize the sdk.
/// <h1>Class</h1>
/// \code
///    AtomConfiguration
///
/// \endcode
SWIFT_CLASS("_TtC8AtomCore17AtomConfiguration")
@interface AtomConfiguration : NSObject
/// <ul>
///   <li>
///     @property secretKey
///   </li>
///   <li>
///     @discussion The Secret Key provided by ATOM at the time of subscription.
///   </li>
/// </ul>
@property (nonatomic, copy) NSString * _Nullable secretKey;
/// The base Url of all the requests to be made by the ATOM SDK. It is optional and can be managed through ATOM Console.
/// <h1>Property</h1>
/// \code
///    baseUrl
///
/// \endcode
@property (nonatomic, copy) NSURL * _Nullable baseUrl;
/// Name of the VPN adapter to be displayed.
/// <h1>Property</h1>
/// \code
///    vpnInterfaceName
///
/// \endcode
@property (nonatomic, copy) NSString * _Nullable vpnInterfaceName;
/// Bundle identifier for ovpn tunnel Provider app extension.
/// <h1>Property</h1>
/// \code
///    ovpn tunnelProviderBundleIdentifier
///
/// \endcode
@property (nonatomic, copy) NSString * _Nullable tunnelProviderBundleIdentifier;
/// Bundle identifier for wireguard tunnel Provider app extension.
/// <h1>Property</h1>
/// \code
///    wireguard tunnelProviderBundleIdentifier
///
/// \endcode
@property (nonatomic, copy) NSString * _Nullable wireGuardTunnelProviderBundleIdentifier;
/// The name of the app group in which the tunnel extension lives in.
/// <h1>Property</h1>
/// \code
///    appGroupIdentifier
///
/// \endcode
@property (nonatomic, copy) NSString * _Nullable appGroupIdentifier;
/// In order to enable OpenVPN log enable this bit. Default is false
/// <h1>Property</h1>
/// \code
///    enableVPNLogs
///
/// \endcode
@property (nonatomic) BOOL enableVPNLogs;
/// The persistVPNDetails used to store last  AtomProperties and AtomConnectionDetails.
/// <h1>Property</h1>
/// \code
///    persistVPNDetails
///
/// \endcode<h1>Available in AtomSDK ~> 3.0</h1>
@property (nonatomic) BOOL persistVPNDetails;
/// The disableAnalytics used to collect the Analytics of Atom SDK.
/// <h1>Property</h1>
/// disableAnalytics
@property (nonatomic) BOOL disableAnalytics;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

typedef SWIFT_ENUM(NSInteger, AtomCoreNetworkError, open) {
  AtomCoreNetworkErrorCoreParsingFailed = 4001,
  AtomCoreNetworkErrorCoreUrlNotFound = 4002,
  AtomCoreNetworkErrorCoreWebClientException = 4003,
  AtomCoreNetworkErrorCoreRequestFailed = 4006,
  AtomCoreNetworkErrorCoreRequestParameterEncodingFailed = 4007,
  AtomCoreNetworkErrorPingFailed = 7309,
};

@class AtomCountryProtocolDns;
/// Property to identify the code of country
/// <h1>Class</h1>
/// \code
///    AtomCountry
///
/// \endcode
SWIFT_CLASS("_TtC8AtomCore11AtomCountry")
@interface AtomCountry : NSObject <NSCoding, NSCopying>
- (id _Nonnull)copyWithZone:(struct _NSZone * _Nullable)zone SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// Property to identify the code of country
/// <h1>Property</h1>
/// \code
///    country
///
/// \endcode
@property (nonatomic, copy) NSString * _Nullable country;
/// Property to identify the name of the country
/// <h1>Property</h1>
/// \code
///    name
///
/// \endcode
@property (nonatomic, copy) NSString * _Nullable name;
/// Property to identify cities in that country
/// <h1>Property</h1>
/// \code
///    cities.
///
/// \endcode
@property (nonatomic, copy) NSArray<AtomCity *> * _Nullable cities;
/// Gets or sets the latitude of the country
/// <h1>Property</h1>
/// \code
///    latitude
///
/// \endcode
@property (nonatomic) double latitude;
/// Gets or sets the logitude of the country
/// <h1>Property</h1>
/// \code
///    longitude
///
/// \endcode
@property (nonatomic) double longitude;
/// Gets or sets the least time a packet takes to be sent to the server of this country plus the length of time it takes for an acknowledgment of that packet to be received at the client depending on user’s network conditions. Default value for this property is 0 when calling Countries
/// <h1>Property</h1>
/// \code
///    latency
///
/// \endcode
@property (nonatomic) NSInteger latency;
/// Gets or sets the ISO Alpha-2 Country code of the current country.
/// <h1>Property</h1>
/// \code
///    iso_code
///
/// \endcode
@property (nonatomic, copy) NSString * _Nullable iso_code;
/// The isSmartDialingSupported. Property to identify which country is Smart Country.
/// <h1>Property</h1>
/// \code
///    isSmartDialingSupported
///
/// \endcode
@property (nonatomic) BOOL isSmartDialingSupported;
/// The rank. Property to identify the rank of Country.
/// <h1>Property</h1>
/// \code
///    rank
///
/// \endcode
@property (nonatomic) NSInteger rank;
/// The isVirtual. Property to identify if country is physically or virtually avaiable.
/// <h1>Property</h1>
/// \code
///    isVirtual
///
/// \endcode
@property (nonatomic) BOOL isVirtual;
/// The acknowledgment_server. Property to identify acknowledgment server
/// <h1>Property</h1>
/// \code
///    acknowledgment_server
///
/// \endcode
@property (nonatomic, copy) NSString * _Nullable acknowledgement_server;
/// Depending on the country. The values will be dependant upon the country provided for connection, representing the available data centers.
/// <h1>Property</h1>
/// \code
///    dataCenters
///
/// \endcode
@property (nonatomic, copy) NSArray<AtomDatacenters *> * _Nullable dataCenters;
/// Gets the protocols supported by this country.
/// <h1>Property</h1>
/// \code
///    protocol
///
/// \endcode
@property (nonatomic, copy) NSArray<AtomProtocol *> * _Nullable protocols;
/// The custom_attributes. Property to identify attributes of country
/// <h1>Property</h1>
/// \code
///    custom_attributes
///
/// \endcode
@property (nonatomic, copy) NSArray<AtomCustomAttributeObjects *> * _Nullable custom_attributes;
/// The countryProtocolDns. Property to identify dns in protocols supported for the country.
/// <h1>Property</h1>
/// \code
///    countryProtocolDns
///
/// \endcode
@property (nonatomic, copy) NSArray<AtomCountryProtocolDns *> * _Nullable countryProtocolDns;
/// The custom_attributes. Property to identify recommended protocol of country
/// <h1>Property</h1>
/// \code
///    recommendedProtocol
///
/// \endcode
@property (nonatomic, strong) AtomProtocol * _Nullable recommendedProtocol;
/// Depending on the country. The feautre list  will be dependant upon the country provided for connection
/// features
@property (nonatomic, copy) NSArray<NSString *> * _Nullable features;
- (void)encodeWithCoder:(NSCoder * _Nonnull)coder;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initFromJSON:(NSDictionary * _Nonnull)fromJSON OBJC_DESIGNATED_INITIALIZER;
- (void)setValue:(id _Nullable)value forUndefinedKey:(NSString * _Nonnull)key;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
@end

SWIFT_CLASS("_TtC8AtomCore22AtomCountryProtocolDns")
@interface AtomCountryProtocolDns : NSObject <NSCoding>
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, copy) NSString * _Nullable id;
@property (nonatomic, copy) NSString * _Nullable country;
@property (nonatomic, strong) AtomProtocol * _Nullable protocols;
@property (nonatomic, strong) AtomDns * _Nullable dns;
@property (nonatomic, copy) NSString * _Nonnull configuration_version;
@property (nonatomic) BOOL multiport_supported;
@property (nonatomic) NSInteger port_number;
@property (nonatomic) NSInteger api_endpoint;
- (void)encodeWithCoder:(NSCoder * _Nonnull)coder;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end

@class AtomMasterCustomAttributes;
SWIFT_CLASS("_TtC8AtomCore26AtomCustomAttributeObjects")
@interface AtomCustomAttributeObjects : NSObject <NSCoding>
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, copy) NSString * _Nullable customAttributeId;
@property (nonatomic, strong) AtomMasterCustomAttributes * _Nonnull masterCustomAttribute;
@property (nonatomic, copy) NSString * _Nullable value;
- (void)encodeWithCoder:(NSCoder * _Nonnull)coder;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end

SWIFT_CLASS("_TtC8AtomCore15AtomDatacenters")
@interface AtomDatacenters : NSObject <NSCoding>
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic) NSInteger dataCenterId;
@property (nonatomic, copy) NSString * _Nullable name;
@property (nonatomic, copy) NSString * _Nullable ip;
@property (nonatomic, copy) NSString * _Nullable hostname;
@property (nonatomic) NSInteger latency;
@property (nonatomic, copy) NSArray<AtomCustomAttributeObjects *> * _Nullable custom_attributes;
- (nonnull instancetype)initFromJSON:(NSDictionary * _Nonnull)fromJSON OBJC_DESIGNATED_INITIALIZER;
- (void)encodeWithCoder:(NSCoder * _Nonnull)coder;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
- (void)setValue:(id _Nullable)value forUndefinedKey:(NSString * _Nonnull)key;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
@end

@class NSNumber;
SWIFT_CLASS("_TtC8AtomCore25AtomDedicatedIPServerPing")
@interface AtomDedicatedIPServerPing : NSObject
- (nonnull instancetype)initWithServerAddress:(NSString * _Nonnull)serverAddress OBJC_DESIGNATED_INITIALIZER;
/// Property to identify the address of the server
/// <h1>Property</h1>
/// serverAddress
@property (nonatomic, copy) NSString * _Nullable serverAddress;
/// Property to identify the serverIP of the server
/// <h1>Property</h1>
/// serverIP
@property (nonatomic, copy) NSString * _Nullable serverIP;
/// Property to identify the latency of the server
/// <h1>Property</h1>
/// latency
@property (nonatomic, strong) NSNumber * _Nullable latency;
/// Property to identify the unit of the latency
/// <h1>Property</h1>
/// \code
///    unit
///
/// \endcode
@property (nonatomic, copy) NSString * _Nullable unit;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

SWIFT_CLASS("_TtC8AtomCore18AtomDefaultAccount")
@interface AtomDefaultAccount : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, copy) NSString * _Nullable id;
@property (nonatomic, copy) NSString * _Nullable vpn_username;
@property (nonatomic, copy) NSString * _Nullable vpn_password;
@end

SWIFT_CLASS("_TtC8AtomCore7AtomDns")
@interface AtomDns : NSObject <NSCoding>
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, copy) NSString * _Nullable hostname;
@property (nonatomic, copy) NSString * _Nullable type;
@property (nonatomic) NSInteger dnsid;
@property (nonatomic, copy) NSString * _Nullable acknowledgementServer;
@property (nonatomic, copy) NSString * _Nullable multiportRange;
@property (nonatomic, copy) NSString * _Nullable configurationVersion;
@property (nonatomic) NSInteger portNumber;
@property (nonatomic) BOOL isMultiport;
@property (nonatomic, copy) NSString * _Nullable ipTranslation;
@property (nonatomic, copy) NSArray<NSString *> * _Nullable tags;
- (void)encodeWithCoder:(NSCoder * _Nonnull)coder;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
@end

/// These properties can be used to identify SDK whether the user is allowed to park in any specific app experiment
/// <h1>Class</h1>
/// AtomExperimentProperties
SWIFT_CLASS("_TtC8AtomCore24AtomExperimentProperties")
@interface AtomExperimentProperties : NSObject
/// This flag will indicate SDK, whether the user is eligible to particate in speed test experiment. If the value is <b>true</b>, it will allow SDK to mark user as experimented user and respectively.
@property (nonatomic) BOOL isExperimentedUser;
/// Network speed of the user before VPN connection
/// <h1>Property</h1>
/// baseSpeed
@property (nonatomic) double baseSpeed;
/// The source of provided base speed
/// <h1>Property</h1>
/// baseSpeedSource
@property (nonatomic, copy) NSString * _Nullable baseSpeedSource;
- (nonnull instancetype)initWithIsExperimentedUser:(BOOL)isExperimentedUser baseSpeed:(double)baseSpeed;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class AtomPackages;
@class AtomPurposes;
SWIFT_CLASS("_TtC8AtomCore10AtomGroups")
@interface AtomGroups : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, copy) NSString * _Nonnull groupId;
@property (nonatomic, copy) NSString * _Nullable name;
@property (nonatomic, copy) NSString * _Nonnull parent_group_id;
@property (nonatomic, copy) NSArray<AtomCustomAttributeObjects *> * _Nullable custom_attributes;
@property (nonatomic, copy) NSArray<AtomProtocol *> * _Nullable protocols;
@property (nonatomic, copy) NSArray<AtomChannel *> * _Nullable channels;
@property (nonatomic, copy) NSArray<AtomCountry *> * _Nullable countries;
@property (nonatomic, copy) NSArray<AtomPackages *> * _Nullable packages;
@property (nonatomic, copy) NSArray<AtomCity *> * _Nullable cities;
@property (nonatomic, copy) NSArray<AtomPurposes *> * _Nullable purposes;
@end

@class Server;
SWIFT_CLASS("_TtC8AtomCore12AtomLocation")
@interface AtomLocation : NSObject <NSCoding>
- (void)encodeWithCoder:(NSCoder * _Nonnull)coder;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCountryObject:(AtomCountry * _Nonnull)countryObject cityObject:(AtomCity * _Nullable)cityObject ipAddress:(NSString * _Nullable)ipAddress OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, strong) AtomCountry * _Nullable country;
@property (nonatomic, strong) AtomCity * _Nullable city;
@property (nonatomic, copy) NSString * _Nullable ip;
@property (nonatomic, strong) Server * _Nullable server;
- (nonnull instancetype)initFromJSON:(NSDictionary * _Nonnull)fromJSON OBJC_DESIGNATED_INITIALIZER;
- (void)setValue:(id _Nullable)value forUndefinedKey:(NSString * _Nonnull)key;
- (void)setValue:(id _Nullable)value forKey:(NSString * _Nonnull)forKey;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

SWIFT_CLASS("_TtC8AtomCore26AtomMasterCustomAttributes")
@interface AtomMasterCustomAttributes : NSObject <NSCoding>
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, copy) NSString * _Nullable id;
@property (nonatomic, copy) NSString * _Nullable attribute;
@property (nonatomic, copy) NSString * _Nullable datatype;
- (void)encodeWithCoder:(NSCoder * _Nonnull)coder;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end

@class AtomOvpnConfigurationProtocol;
SWIFT_CLASS("_TtC8AtomCore21AtomOvpnConfiguration")
@interface AtomOvpnConfiguration : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, copy) NSString * _Nullable configuration_version;
@property (nonatomic, copy) NSArray<AtomOvpnConfigurationProtocol *> * _Nullable protocols;
@end

SWIFT_CLASS("_TtC8AtomCore29AtomOvpnConfigurationProtocol")
@interface AtomOvpnConfigurationProtocol : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, copy) NSString * _Nullable ovpnConfigurationId;
@property (nonatomic, copy) NSString * _Nullable configuration;
@property (nonatomic, copy) NSString * _Nullable configuration_version;
@property (nonatomic, strong) AtomProtocol * _Nonnull protocols;
@end

SWIFT_CLASS("_TtC8AtomCore12AtomPackages")
@interface AtomPackages : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, copy) NSString * _Nonnull packageId;
@property (nonatomic, copy) NSString * _Nullable name;
@property (nonatomic, copy) NSString * _Nonnull multi_login;
@property (nonatomic, copy) NSString * _Nonnull session_limit;
@property (nonatomic, copy) NSString * _Nonnull accounts;
@property (nonatomic, copy) NSString * _Nonnull concurrent_users;
@property (nonatomic) NSInteger bandwidth;
@property (nonatomic, copy) NSArray<AtomProtocol *> * _Nullable protocols;
@property (nonatomic, copy) NSArray<AtomChannel *> * _Nullable channels;
@property (nonatomic, copy) NSArray<AtomCountry *> * _Nullable countries;
@property (nonatomic, copy) NSArray<AtomPurposes *> * _Nullable purposes;
@property (nonatomic, copy) NSArray<AtomCity *> * _Nullable cities;
@property (nonatomic, copy) NSArray<AtomCustomAttributeObjects *> * _Nullable custom_attributes;
@end

SWIFT_CLASS("_TtC8AtomCore12AtomProtocol")
@interface AtomProtocol : NSObject <NSCoding>
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// Gets or sets the name the protocol.
/// <h1>Property</h1>
/// \code
///    name
///
/// \endcode
@property (nonatomic, copy) NSString * _Nullable name;
/// Get or sets the protocol
/// <h1>Property</h1>
/// \code
///    protocol
///
/// \endcode
@property (nonatomic, copy) NSString * _Nullable protocol;
/// Get or sets the port_number
/// <h1>Property</h1>
/// \code
///    port_number
///
/// \endcode
@property (nonatomic) NSInteger port_number;
/// Get or sets the multiport_range
/// <h1>Property</h1>
/// \code
///    multiport_range
///
/// \endcode
@property (nonatomic, copy) NSString * _Nullable multiport_range;
/// Get or sets the configuration
/// <h1>Property</h1>
/// \code
///    configuration
///
/// \endcode
@property (nonatomic, copy) NSString * _Nullable configuration;
/// Get or sets the multiport_supported
/// <h1>Property</h1>
/// \code
///    multiport_supported
///
/// \endcode
@property (nonatomic) BOOL multiport_supported;
/// The dns. Depending on the protocol.
/// <h1>Property</h1>
/// \code
///    dns
///
/// \endcode
@property (nonatomic, copy) NSArray<AtomDns *> * _Nullable dns;
/// The protocolSwitch. Depending on the protocol.
/// <h1>Property</h1>
/// \code
///    protocolSwitch
///
/// \endcode
@property (nonatomic, copy) NSArray<AtomProtocol *> * _Nullable protocolSwitch;
/// The custom_attributes. Property to identify attributes of city
/// <h1>Property</h1>
/// \code
///    custom_attributes
///
/// \endcode
@property (nonatomic, copy) NSArray<AtomCustomAttributeObjects *> * _Nullable custom_attributes;
- (void)encodeWithCoder:(NSCoder * _Nonnull)coder;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end

SWIFT_CLASS("_TtC8AtomCore22AtomPurposeProtocolDns")
@interface AtomPurposeProtocolDns : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, copy) NSString * _Nonnull id;
@property (nonatomic) NSInteger purposeId;
@property (nonatomic, strong) AtomProtocol * _Nullable protocols;
@property (nonatomic, strong) AtomDns * _Nullable dns;
@property (nonatomic, copy) NSString * _Nonnull configuration_version;
@property (nonatomic) BOOL multiport_supported;
@property (nonatomic) NSInteger port_number;
@property (nonatomic) NSInteger api_endpoint;
@end

SWIFT_CLASS("_TtC8AtomCore12AtomPurposes")
@interface AtomPurposes : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic) NSInteger purposeId;
@property (nonatomic, copy) NSString * _Nullable name;
@property (nonatomic, copy) NSArray<AtomCountry *> * _Nullable countries;
@property (nonatomic, copy) NSArray<AtomProtocol *> * _Nullable protocols;
@property (nonatomic, copy) NSArray<AtomPurposeProtocolDns *> * _Nullable purposeProtocolDns;
@property (nonatomic, copy) NSArray<AtomCustomAttributeObjects *> * _Nullable custom_attributes;
@end

SWIFT_CLASS("_TtC8AtomCore12AtomReseller")
@interface AtomReseller : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic) NSInteger resellerId;
@property (nonatomic, copy) NSString * _Nullable resellerUId;
@end

typedef SWIFT_ENUM(NSInteger, AtomSDKError, open) {
  AtomSDKErrorSecretKeyRequired = 5001,
  AtomSDKErrorAccessTokenRequestFailed = 5002,
  AtomSDKErrorAccessTokenGeneralError = 5003,
  AtomSDKErrorAccessTokenJsonNotSerialized = 5005,
};

@class AtomSmartConnectProtocolDns;
SWIFT_CLASS("_TtC8AtomCore16AtomSmartConnect")
@interface AtomSmartConnect : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic) NSInteger id;
@property (nonatomic, copy) NSString * _Nullable name;
@property (nonatomic, copy) NSString * _Nullable title;
@property (nonatomic, copy) NSArray<AtomProtocol *> * _Nullable protocols;
@property (nonatomic, copy) NSArray<AtomSmartConnectProtocolDns *> * _Nullable smartConnectProtocolDns;
@property (nonatomic, copy) NSString * _Nullable host;
@property (nonatomic, copy) NSString * _Nullable configurationVersion;
@property (nonatomic, copy) NSString * _Nullable dnsType;
@property (nonatomic, copy) NSString * _Nullable protocol;
@property (nonatomic) NSInteger protocolNumber;
@property (nonatomic) BOOL isMultiport;
@property (nonatomic, copy) NSArray<NSString *> * _Nullable tags;
@end

SWIFT_CLASS("_TtC8AtomCore27AtomSmartConnectProtocolDns")
@interface AtomSmartConnectProtocolDns : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, copy) NSString * _Nonnull id;
@property (nonatomic) NSInteger smartConnectId;
@property (nonatomic, strong) AtomProtocol * _Nullable protocols;
@property (nonatomic, strong) AtomDns * _Nullable dns;
@property (nonatomic) NSInteger api_endpoint;
@property (nonatomic, copy) NSString * _Nonnull configuration_version;
@property (nonatomic) BOOL multiport_supported;
@property (nonatomic) NSInteger port_number;
@end

typedef SWIFT_ENUM(NSInteger, AtomSmartConnectTag, open) {
  AtomSmartConnectTagAutomatic = 0,
  AtomSmartConnectTagFileSharing = 1,
  AtomSmartConnectTagFreeFileSharing = 2,
  AtomSmartConnectTagAutomaticFileSharing = 3,
  AtomSmartConnectTagFreeUsers = 4,
  AtomSmartConnectTagNatted = 5,
  AtomSmartConnectTagNattedFileSharing = 6,
  AtomSmartConnectTagPaid = 7,
  AtomSmartConnectTagAvfFileSharing = 8,
  AtomSmartConnectTagAvfSecurity = 9,
};

SWIFT_PROTOCOL("_TtP8AtomCore15ManagerProtocol_")
@protocol ManagerProtocol
@property (nonatomic, strong) AtomConfiguration * _Nullable atomConfiguration;
@property (nonatomic, strong) AccessTokenModel * _Nullable accessToken;
@property (nonatomic, copy) NSString * _Nullable activeBaseUrl;
@property (nonatomic, strong) ApiBaseUrlModel * _Nullable apiUrl;
@end

SWIFT_PROTOCOL("_TtP8AtomCore12PingProtocol_")
@protocol PingProtocol
- (void)getOptimizedCountriesWithResponse:(void (^ _Nonnull)(NSArray<AtomCountry *> * _Nullable, NSError * _Nullable))response;
- (void)getOptimizedCitiesWithResponse:(void (^ _Nonnull)(NSArray<AtomCity *> * _Nullable, NSError * _Nullable))response;
- (void)getOptimizedDataCentersWithResponse:(void (^ _Nonnull)(NSArray<AtomDatacenters *> * _Nullable, NSError * _Nullable))response;
@end

@interface NSArray<ObjectType> (SWIFT_EXTENSION(AtomCore)) <PingProtocol>
- (void)getOptimizedCountriesWithResponse:(void (^ _Nonnull)(NSArray<AtomCountry *> * _Nullable, NSError * _Nullable))response;
- (void)getOptimizedCitiesWithResponse:(void (^ _Nonnull)(NSArray<AtomCity *> * _Nullable, NSError * _Nullable))response;
- (void)getOptimizedDataCentersWithResponse:(void (^ _Nonnull)(NSArray<AtomDatacenters *> * _Nullable, NSError * _Nullable))response;
@end

@interface NSError (SWIFT_EXTENSION(AtomCore))
+ (NSError * _Nullable)errorWithResponseParams:(NSDictionary * _Nonnull)responseParams domain:(NSString * _Nonnull)domain SWIFT_WARN_UNUSED_RESULT;
+ (NSError * _Nullable)errorWithCode:(NSInteger)code message:(NSString * _Nonnull)message domain:(NSString * _Nonnull)domain SWIFT_WARN_UNUSED_RESULT;
+ (NSError * _Nullable)errorWithCode:(NSInteger)code errorMessage:(NSString * _Nonnull)errorMessage andFailureMessage:(NSString * _Nonnull)andFailureMessage domain:(NSString * _Nonnull)domain SWIFT_WARN_UNUSED_RESULT;
@end

SWIFT_CLASS("_TtC8AtomCore6Server")
@interface Server : NSObject <NSCoding>
@property (nonatomic, copy) NSString * _Nullable nasIdentifier;
- (void)encodeWithCoder:(NSCoder * _Nonnull)coder;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
- (void)setValue:(id _Nullable)value forKey:(NSString * _Nonnull)forKey;
- (void)setValue:(id _Nullable)value forUndefinedKey:(NSString * _Nonnull)key;
- (nonnull instancetype)initFromJSON:(NSDictionary * _Nonnull)fromJSON OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

SWIFT_CLASS("_TtC8AtomCore21SmartConnectTagHelper")
@interface SmartConnectTagHelper : NSObject
+ (NSString * _Nonnull)getStringFrom:(enum AtomSmartConnectTag)from SWIFT_WARN_UNUSED_RESULT;
+ (enum AtomSmartConnectTag)getTagFromString:(NSString * _Nonnull)from SWIFT_WARN_UNUSED_RESULT;
+ (enum AtomSmartConnectTag)getTagFromInt:(NSInteger)from SWIFT_WARN_UNUSED_RESULT;
+ (NSString * _Nonnull)getTagValueFromInt:(NSNumber * _Nonnull)from SWIFT_WARN_UNUSED_RESULT;
+ (NSArray<NSNumber *> * _Nonnull)getAvailableTags SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

#endif
#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#if defined(__cplusplus)
#endif
#pragma clang diagnostic pop
#endif

#else
#error unsupported Swift architecture
#endif
